
namespace Anycmd.Model
{

    /// <summary>
    /// 标记接口。表示该类型是实体，实体一般在数据库中对应有持久表或视图。
    /// </summary>
    public interface IEntity<out TEntityId>
    {
        /// <summary>
        /// 实体标识。
        /// <remarks>
        /// 实体标识是个什么东西？标识就是指针，标识就是引用，标识就是节点内部用来识别区分本节点内的空间或过程的记号。
        /// 所有的引用都只是节点内的引用，具体的引用类型被定义在的那个节点就是它的边界。所有的引用类型当被传出本
        /// 节点外的时候都是要被序列化为值类型，这转化后得到的值类型上一定有那个引用类型的元数据（基本类型的元数据
        /// 被定义在计算机行业标准这个节点中，大家的系统都是这个节点的后代节点）。标识是节点内的标识，比如某个teacher
        /// 对象的标识是123456，比如这个标识被传到它的父节点的时候会是teacher/123456，再往上传到就需要是
        /// person/teacher/123456了，被传给非父节点的时候所用的标识一定是一直从sender节点和receiver节点共同的父节点
        /// 开始一级一级的组成的。 运行在.net CLR中的对象都处在CLR这个节点内，而持久库是另一个节点，这时两个节点间要
        /// 交换数据。无论CLR的运行时对象标识还是数据库的主键标识都不能用来充当CLR和数据库这两个节点间的数据交换标识，
        /// 这时需要一个定义在CLR和数据库这两个节点的共同父节点中的标识，它就是我们的领域实体中的标识了。CLR节点和
        /// 数据库节点的共同父节点是哪个节点呢？是我们的系统，它是缺省节点。 
        /// </remarks>
        /// </summary>
        TEntityId Id { get; }
    }
}
